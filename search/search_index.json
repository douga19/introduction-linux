{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TI307I - Introduction to Linux","text":""},{"location":"#course-description","title":"Course description","text":"<p>This course is an introduction to the concept of operating systems, and in particular GNU/Linux based operating systems. You will discover the philosophy, operations, basic components and powerful tools found on GNU/Linux systems through one of its distributions: Debian.</p> <p>This year the coordinator of this module will be M. Rado Rakotonarivo. You can contact him at <code>rado.rakotonarivo@efrei.fr</code>.</p>"},{"location":"#sequencencing","title":"Sequencencing","text":"<p>This module will be taught in 15 hours as a Lab/Lecture sessions.</p> <ul> <li>Week 36: 3 hours of lab work</li> <li>Week 37: 3 hours of lab work</li> <li>Week 38: 3 hours of lab work</li> <li>Week 39: 3 hours of lab work + 25 minutes of evaluation (CC)</li> <li>Week 40: 2 hours of lab work</li> <li>Week 41: 1 hour of final examination (DE)</li> </ul>"},{"location":"#group-repartition","title":"Group repartition","text":"Group Teacher Contact A Zouhour Guiras zouhour.guiras@intervenants.efrei.net B Halim Djerroud halim.djerroud@intervenants.efrei.net C Borhene Eddine Dakkar borhen-eddine.dakkar@intervenants.efrei.net D Zouhour Guiras zouhour.guiras@intervenants.efrei.net E Mourad Kmimech mourad.kmimech@efrei.fr F Rado Rakotonarivo rado.rakotonarivo@efrei.fr P Nathalie Xiaodan Chin nathalie.xiaodan-chin@intervenants.efrei.net BN Nathalie Xiaodan Chin nathalie.xiaodan-chin@intervenants.efrei.net BDX John Dreyfus john.dreyfus@intervenants.efrei.net INT1 Rostom Kachouri rostom.kachouri@intervenants.efrei.net INT2 Nathalie Xiaodan Chin nathalie.xiaodan-chin@intervenants.efrei.net INT3 Rado Rakotonarivo rado.rakotonarivo@efrei.fr"},{"location":"#course-contents","title":"Course contents","text":"<ol> <li>Get yourself a Linux environment</li> <li>Preliminary reading</li> <li>Lab1 - First commands</li> <li>Lab2 - File System and permissions</li> <li>Lab3 - Working environment</li> <li>Lab4 - Text filters, redirections and pipes</li> <li>Lab5 - Processes and other commands</li> </ol>"},{"location":"contents/installation-wsl/","title":"Get yourself a Linux environment","text":""},{"location":"contents/installation-wsl/#installation-of-wsl-for-windows-users","title":"Installation of WSL (for Windows users)","text":"<p>In this tutorial we will see how you can directly have a Linux environment in Windows using Windows Subsystem for Linux (WSL).</p>"},{"location":"contents/installation-wsl/#wsl-activation","title":"WSL activation","text":"<ol> <li>In the search bar of Windows, type \"Activer ou d\u00e9sactiver des Fonctionnalit\u00e9s Windows\". </li> <li>There will be a dialog box in which we will check options.</li> <li>Make sure that the options Sous-syst\u00e8me Windows pour Linux and Plateforme de machine virtuelle are checked and click on OK. </li> <li>You will probably be asked to restart your computer for the changes to take effect.</li> </ol>"},{"location":"contents/installation-wsl/#gnulinux-distribution-installation-debian","title":"GNU/Linux distribution installation (Debian)","text":"<ol> <li>Open up Microsoft Store and type debian in the search bar. Once Debian is proposed in the suggestions, click on it.</li> <li>Click on Obtenir. </li> <li>Once the download is finished (about 80MB), search for Debian in the Windows search bar and click on it.</li> <li>A terminal emulator named Debian will open and finalize the installation.</li> <li>In this terminal, once the installation is finished, you will be asked to enter a username and a password. Note that for security reasons, the password you will type will not appear in clear, you may have the impression of not typing anything, but in fact yes.</li> <li>Once your login and password have been entered, that's it! You now have a GNU/Linux system (command line) installed in Windows.</li> </ol>"},{"location":"contents/installation-wsl/#browse-the-wsl-files-from-windows","title":"Browse the WSL files from Windows","text":"<ol> <li>Open a file explorer from Windows.</li> <li>In the adress bar, type: <code>\\\\wsl$</code>, then press enter. </li> <li>From there, you will be able to access your personal directory by clicking on <code>home</code> then on the folder whose name is your <code>login</code>. </li> <li>From now, you are able to retrieve your debian files from Windows.</li> <li>To test that everything is fine, in the debian terminal enter the following command:  <pre><code>touch file.txt\n</code></pre> then from the Windows file explorer check that the file has been created in your personal directory (you may need to refresh the window with <code>F5</code>).</li> <li>Edit <code>file.txt</code> in a text editor from Windows, then save it. </li> <li>Finally, go back to the debian terminal to check that the file has been modified. Type the command: <pre><code>cat file.txt\n</code></pre></li> <li>You may observe a small problem with the end of lines, Windows and Unix manage them differently (we will talk about it later).</li> </ol>"},{"location":"contents/installation-wsl/#installation-of-utm-for-macos-users","title":"Installation of UTM (for MacOS users)","text":"<p>In this tutorial we will see how you can directly have a Linux environment in MacOS using UTM.</p>"},{"location":"contents/installation-wsl/#utm-and-debian-installation","title":"UTM and Debian installation","text":"<ol> <li>Download the UTM application from the App Store. Or directely from here.</li> <li>Open the application, there will be options to install and emulate an OS (Windows, Linux, Android, ...). We will choose Linux.</li> <li>Click on the Browse UTM gallery button, it will open up the UTM Virtual OS gallery.</li> <li> <p>Choose one of the Debian 11 distribution of your choice (for this tuto I choose the one with Xfce graphical environment).     </p> </li> <li> <p>Then click on Open in UTM button, this will download the image and install Debian on your computer.</p> </li> <li>Once the installation is finished, get back to the UTM application, you will see the Debian OS in the list of the installed OS.</li> <li>Click on the Debian OS, then click on the Play button.</li> <li>You will end up in a login page, enter your username and password (the default username is <code>debian</code> and the default password is <code>debian</code>).</li> <li>Pay attention to the keyboard layout, it may be different from the one you are used to. It is by default the QWERTY keyboard layout.</li> </ol>"},{"location":"contents/installation-wsl/#keyboard-layout-change","title":"Keyboard layout change","text":"<ol> <li>To change the keyboard layout, click on the Applications button on the top left corner of the screen. </li> <li>There will be a list of applications, click on the Settings application, then on Keyboard.</li> <li>You will have a window with the keyboard settings, click on the Layout tab.</li> <li>From there, change the keyboard model to MacBook/MacBook Pro and on the keyboard layout option, click on the Add button choose the one you are used to (for me it is French (AZERTY)).</li> <li>You can by now delete the default keyboard layout which was the QWERTY one.</li> <li> <p>At the end of the configuration you should end up with something similar to this:    </p> </li> <li> <p>You can close the window, and now you can use the keyboard layout you are used to.</p> <p>On the login screen</p> <p>On the login screen the keyboard layout will remain the default one i.e. QWERTY. So you will have to type your password with the QWERTY layout.</p> </li> </ol>"},{"location":"contents/installation-wsl/#sharing-macos-folder-with-your-debian-os","title":"Sharing MacOs folder with your Debian OS","text":"<p>For this step, you will need to have a folder in your MacOS that you want to share with your Debian OS. For this tutorial, I will use a folder named <code>ti307-introduction-to-linux</code>.</p> <ol> <li>First you need to turn off the Debian OS by clicking on the Stop button in the UTM application.</li> <li>Then right click on Debian OS on the list of the installed OS, and click on the Edit button.</li> <li>You will have several options to configure your OS, we will focus on the Share option.</li> <li>Click on Share option, and browse then select the folder you want to share from your MacOS. Let the other options as they are.</li> <li> <p>At the end of this step your Debian OS configuration should be similar to this:</p> <p></p> </li> <li> <p>Now you can turn on your Debian OS by clicking on the Play button.</p> </li> <li>Log in, then on your desktop you should find a Volume Disk named <code>share</code>. Double click on it and you should retrieve the folder you shared from MacOS.</li> <li> <p>In this file explorer window, right click and choose Open in Terminal Here. Then type the following command: <pre><code>sudo touch file.txt\n</code></pre></p> <p><code>sudo</code> ?</p> <p>The <code>sudo</code> command allows you to execute the command that follows it as an administrator. You will be asked for your password (once per session).</p> </li> <li> <p>Get back into your MacOs file explorer, you should find the file <code>file.txt</code> in the folder you shared. Then from there, edit this file using a text editor.</p> </li> <li> <p>Get back to the Debian terminal, and type the following command: <pre><code>sudo cat file.txt\n</code></pre> If you are able to see on the terminal the content of <code>file.txt</code>, everything went right and from now you can share files between MacOS and Debian.</p> <p>Path to the shared directory</p> <p>In the Debian OS, the path to the shared directory is <code>/media/share</code>. Make sure that you remember this :)</p> </li> </ol>"},{"location":"contents/installation-wsl/#install-debian-packages-with-apt","title":"Install Debian packages with <code>apt</code>","text":"<p>Most of the GNU/Linux distributions allow to install programs, libraries (set of programs), precompiled software by going through online repositories. The programs and libraries present in these repositories are called packages.</p> <p>The installation of these packages is performed by a ... package manager. Debian and its derivatives, the package manager is called <code>apt</code>.</p> <p>Since those packages are installed on the system, for all users, only the system administrator is allowed to install them, but you will be able to take this role.</p> <p>Let us install some packages.</p> <ol> <li>Open up a terminal. And first, update the database and the already installed packages by typing: <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> This step may take more or less time depending on your internet connection.</li> <li>Once the updates are done, we will install 4 packages: the text editors <code>nano</code> and <code>vim</code>, the c compiler <code>gcc</code> and a calandar app <code>ncal</code> with the following command: <pre><code>sudo apt install nano vim gcc ncal\n</code></pre></li> <li>It is also possible to search for packages by name or keyword using the <code>search</code> action of the <code>apt</code> command.</li> <li>To remove / uninstall a package, use the <code>remove</code> action of the <code>apt</code> command: <pre><code>sudo apt remove nano\n</code></pre></li> <li>Finally, some libraries become useless once the packages that used them are removed. The <code>autoremove</code> action allows you to clean up by uninstalling the libraries that have become useless. <pre><code>sudo apt autoremove\n</code></pre></li> </ol>"},{"location":"contents/preliminary-reading/","title":"Preliminary reading","text":"<p>In this introductory course, we are going to learn how to use Linux operating system through the Debian distribution. We will learn how to use the command line interface (CLI) and how to use the shell to interact with the operating system. We will also learn how to use the shell to write scripts and automate tasks.</p> <p>This preliminary reading refers the genesis of Linux in ordrer to grasp the philosophy behind it and understand why it is so popular, even if you have never heard of it before. Yes, you may not know but you are already using it everyday. A definition of a shell is also provided.</p>"},{"location":"contents/preliminary-reading/#what-is-an-operating-system","title":"What is an operating system ?","text":"<p>According to Wikipedia, the free encyclopedia, an operating system (OS) is system software that manages computer hardware and software resources, and provides common services for computer programs. </p> <p>It receives requests to use the computer's resources - memory storage resources (e.g. access to RAM, hard disks), central processor computing resources, communication resources to peripherals (e.g. to request computing resources from the GPU or any other expansion card) or via the network - from application software. The operating system manages these requests and the necessary resources to avoid interference between software applications.</p>"},{"location":"contents/preliminary-reading/#what-is-unix","title":"What is UNIX ?","text":"<p>UNIX was an OS originally developed by Ken Thompson at Bell Labs, the legendary research arm of AT&amp;T (the former U.S. telecommunications monopoly) in 1969 and was substantially improved at the University of California at Berkeley (UCB) during the 1970s and 1980s. Many variations were subsequently developed, and they are collectively referred to as Unix-like, or Unix-based operating systems. Unix-based operating systems are widely regarded as the best operating systems ever created in terms of several criteria, including stability, security, flexibility, scalability and elegance.</p>"},{"location":"contents/preliminary-reading/#what-is-linux-and-gnulinux","title":"What is Linux and GNU/Linux ?","text":"<p>Linux is a high-performance, free operating system similar to UNIX. Linus Torvalds started Linux (a concatenation of Linus and UNIX) in 1991, aiming to create a free UNIX alternative due to dissatisfaction with MS-DOS. It rapidly became a global project, attracting developers worldwide [^1], leading to continuous performance improvements and widespread adoption by individuals, corporations, educational institutions, and governments.</p> <p>Linux's superiority over other Unix-like systems lies in being completely free, both monetarily and in terms of usage rights. This freedom is enabled by the GNU General Public License (GPL), associated with the GNU project started by Richard Stallman in 1983, providing critical utility programs for Linux, hence the name GNU/Linux.</p> <p>Compared to Microsoft Windows, the most widely used OS, Linux offers several benefits: (1) being free, (2) high stability with fewer crashes, (3) strong resistance to viruses and malware, (4) availability of numerous high-quality, free applications, and (5) compatibility with older computers unable to support newer Windows versions. For a more comprehensive list of advantages, the article \"25 Reasons to Convert to Linux\" can provide further insights.</p>"},{"location":"contents/preliminary-reading/#what-is-a-linux-distribution","title":"What is a Linux distribution ?","text":"<p>A distribution is a complete operating system consisting of a \\emph{kernel} (i.e., the core of an operating system) and utilities (some of which are also necessary for functioning of the operating system) together with a variety of application programs. </p> <p>There exists a hundred of currently available distributions of Linux. They come with various flavour from the most user friendly for complete beginners to the most advanced for experts. The most popular of these are Ubuntu, Fedora, Debian.</p> <p>Most of these distributions are available (1) in English, (2) for Intel-compatible (x86) processors and (3) as free downloads from the Internet. They are also available (4) in other languages and (5) for other types of processors.</p> <p>In this course we are going to start our Linux journey with Debian.</p>"},{"location":"contents/preliminary-reading/#what-is-debian","title":"What is Debian ?","text":"<p>Debian is a free operating system (OS) based on a UNIX-like kernel (Linux or FreeBSD) that can be dowloaded here. You can find more information about Debian here. In order to install it on your computer, please refer to the tutorial already provided on the moodle page of the course.</p>"},{"location":"contents/preliminary-reading/#key-dates-in-the-history-of-unix-and-linux","title":"Key dates in the history of UNIX and Linux","text":"<ul> <li>1969: Ken Thompson develops the first version of UNIX at Bell Labs.</li> <li>1973: UNIX is rewritten in the C programming language, greatly increasing its portability.</li> <li>1983: Richard Stallman starts the GNU project to create a free UNIX-like operating system providing a lot of utilities.</li> <li>1985: The Free Software Foundation is founded to support the GNU project.</li> <li>1987: Andrew Tanenbaum develops MINIX, a free UNIX-like operating system for educational purposes.</li> <li>1991: Linus Torvalds starts Linux as a hobby project.</li> <li>1992: Linux is relicensed under the GNU GPL.</li> <li>1993: The Debian project is founded to create a free UNIX-like operating system.</li> </ul>"},{"location":"contents/preliminary-reading/#unix-based-os-today","title":"UNIX-based OS today","text":"<ul> <li>GNU/Linux Linux kernel + GNU utilities, equips most servers and supercomputers, and is increasingly used on desktops and laptops (1% to 2%).</li> <li>Android Linux kernel + Android utilities, equips most smartphones and tablets (80%).</li> <li>FreeBSD UNIX-like OS, equips most Apple Macintosh computers (10%), and the OS of Playstation 3 and 4.</li> <li>iOS and MacOS UNIX-like OS, equips iPhones and iPads and Macs from Apple.</li> </ul>"},{"location":"contents/preliminary-reading/#what-is-a-shell","title":"What is a shell ?","text":"<p>We saw that an OS manages user requests to use the computer's resources. These requests are made through a user interface. There are two types of user interfaces: (1) graphical user interfaces (GUIs) and (2) command line interfaces (CLIs).</p> <p>A shell is a program that provides the traditional, text-only user interface for Unix-like operating systems. Its primary function is to read commands (i.e., instructions) that are typed into a console (i.e., an all-text display mode) or terminal window (i.e., a graphical display mode), and then execute (i.e., run) them.</p> <p>In this course we will use the Bash shell. Bash is the GNU Project's shell. Bash is the Bourne Again SHell. Bash is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and C shell (csh). It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools standard. It offers functional improvements over sh for both programming and interactive use. In addition, most sh scripts can be run by Bash without modification.</p> <p>[^1]: Later, Linus Torvalds will invent Git in order to manage the developement of Linux Kernel as its developement has been spread worldwide.</p>"},{"location":"contents/tp1/","title":"Lab1 - First commands","text":"<p>General instructions<ul> <li>In all exercises, the <code>$</code> chain at the beginning of the line represents the command prompt and should not be typed.</li> <li>For now, each time you open a terminal, you are prompted to enter the following command, (followed, as always, by the enter key) for pedagogical reasons:</li> </ul> <pre><code>$ PS1='$ '\n</code></pre> </p>"},{"location":"contents/tp1/#exercise-1-first-commands","title":"Exercise 1 : First commands","text":"<p>What is a command ?</p> <p>A command  is a sequence of words ending with a newline character. That is, a command is a sequence of characters that ends with the <code>&lt;Enter&gt;</code> key. The first word is the name of the command, the others are its arguments. The command is executed by the shell, which is a program that interprets the command line.</p> <pre><code>$ touch file.txt\n</code></pre> <p>Here the command is <code>touch</code> and its argument is <code>file.txt</code>. The <code>$</code> sign at the begining of the line is the command prompt. It is not part of the command.</p> <p>Every single word in the command line is separated by one or more spaces. The shell interprets the spaces as separators between words. The shell interprets the newline character as the end of the command.</p> <ol> <li>Try out the following commands in a terminal. Describe in one sentence its usefulness, indicate the name of the command, its number of arguments and its arguments. For example, the first command is <code>date</code>, it has no argument and its usefulness is to display the current date and time. <pre><code>$ date\n$ cal\n$ cal 3 2022\n$ who\n$ who am i\n$   who  am   i\n$ uname\n$ uname -m -r\n$ uname -mrs\n$ echo Hello, world!\n$ echo       Hello,        world!\n</code></pre></li> <li>Press on the right arrow key of your keyboard or <code>C-p</code> (the <code>Ctrl</code> key at the same time as the <code>p</code> key) several times, until the command <code>who</code> is displayed. Now press the down arrow key or type <code>C-n</code> until the command <code>uname -m -r</code> is displayed and then press enter. Note what these shortcuts are for and learn them.</li> <li>Press <code>C-l</code>. Note what this shortcut is for and learn it.</li> <li>Without explicitly write the command, display the command <code>cal 3 2022</code>, without executing it (i.e. without pressing enter).</li> <li>Press <code>C-u</code>. Note what this shortcut is for and learn it.</li> <li>Display again the command <code>uname</code>, without typing it nor executing it. Then press <code>C-d</code>. What happened ?</li> <li>Clear the current command line with a keyboard shortcut and then type <code>C-d</code>. What happened ?</li> <li>Open again a terminal and type <code>C-p</code> several times. Comment.</li> <li>Close the terminal using keyboard shortcuts.</li> </ol>"},{"location":"contents/tp1/#exercise-2-directories-and-files","title":"Exercise 2 : Directories and files","text":"<ol> <li>Open a terminal and type the following command, respecting its syntax: <pre><code>PS1='$ '\n</code></pre></li> <li>Type the command <code>pwd</code> (for print working directory), that is, display the name of the current directory) and note what is printed on the screen: it is the absolute path of your home, personal directory.</li> <li>Type the command <code>cd ..</code> (with a space between <code>cd</code> and <code>..</code>) and then <code>pwd</code>. Repeat these two commands several times until the result remains the same. What happened ?</li> <li>Type the command <code>cd</code> (without argument), then <code>pwd</code>. Comment.</li> <li>Type the command <code>cd /</code>, then <code>pwd</code> and <code>ls</code>.</li> <li>Type the command <code>cd /usr/include</code>. Use the command <code>ls</code>. What does this directory seem to be used for ?</li> <li>The <code>cat</code> command (for concatenate) displays one or more files given as arguments (one after the other) in the terminal. The <code>wc</code> command (for word count) displays (in this order) the number of lines, words and characters of the files given as arguments, then, if there are several, the sums of these numbers for all the files. Display the contents of the <code>stdlib.h</code> file and the number of lines of this file.</li> <li>Type the commands <code>cd ..</code>, <code>pwd</code> and <code>ls</code>.</li> <li>Type the commands <code>cd share/man</code>, then <code>pwd</code> and <code>ls</code>. Can you guess what some of the displayed results refer to ?</li> <li>Type the command <code>ls /bin</code>. Are some of the names familiar to you ?</li> <li>The <code>~</code> character (which is read tilde) is entered on the keyboard with the key combination <code>Alt Gr-2</code>. Enter the command <code>echo ~</code>, then the command <code>cd ~</code>. What did the shell do to the character <code>~</code> ?</li> <li>Represent the directories and files mentioned in the exercise as a tree (i.e. as a genealogical tree).</li> </ol>"},{"location":"contents/tp1/#exercise-3-manipulating-directories-and-files-1","title":"Exercise 3 : Manipulating directories and files (1)","text":"<p>Path access</p> <p>A ressource (file or directory) is referenced by a path. In this path, under Linux, the names of the directories and files are separated by a slash <code>/</code> (while we use a backslash <code>\\</code> under Windows).</p> <p>There exists two types of paths: absolute and relative.</p> <ol> <li>An absolute path is based on the root of the tree and starts with <code>/</code>, for example: <code>/home/debian</code> is the absolute path to the user debian's home directory. It remains valid regardless of the context.</li> <li>A relative path is relative to the current directory where the user is located. For example, if the current directory is <code>/home/debian</code>, the relative path <code>./Documents</code> refers to the directory <code>/home/debian/Documents</code>. A path that starts with something other than <code>/</code> or <code>~</code> is a relative path.</li> </ol> <p>The <code>.</code> references the current directory. The <code>..</code> references the parent directory.</p> <ol> <li>Make sure you are in your home directory and list its contents.</li> <li>Type the command <code>mkdir tp_shell</code> (for make directory, i.e. create a directory). List the contents of the home directory and the <code>tp_shell</code> directory.</li> <li>Type the command <code>mkdir abeilles tp_shell/tp1 ~/arbres</code>. What did it do ? Among its arguments, which are absolute paths and which are relative paths ? (hint: see the result of <code>echo ~/arbres</code>).</li> <li>What does the following command do ? <pre><code>$ mkdir -p vivant/plante/fleur tp_shell/tp1/exos/ex1/\n</code></pre></li> <li>The <code>bash</code> shell (which is your default shell) has a feature that saves a lot of time and avoids typos: automatic completion. It is done with the tabulation key (the key to the left of the <code>a</code> key). Enter the following characters (the tabulation key is represented below by <code>&lt;Tab&gt;</code>) and see the result in the terminal: <pre><code>$ mkd&lt;Tab&gt; vi&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;roses\n</code></pre></li> <li>When several choices are possible, tabulation does not trigger completion, but pressing the tabulation key twice in a row lists the possible choices: try with <pre><code>$ ls a&lt;Tab&gt;&lt;Tab&gt;\n</code></pre></li> <li>The <code>rmdir</code> command (for remove directory) allows you to delete directories. Test it with the command <pre><code>$ rmdir vivant tp_shell/tp1/exos/ex1\n</code></pre> and then delete the subdirectory <code>tp1</code> from the directory <code>tp_shell</code>.</li> <li>The <code>touch</code> command allows (among other things) to create empty (normal) files. Observe the result of the command (executed from your home directory): <pre><code>$ touch ~/arbres/hello.c abeilles/truc.txt bidule\n</code></pre> by typing <pre><code>$ ls ~/arbres abeilles/ .\n</code></pre></li> <li>The <code>mv</code> command for move, allows you to move or rename files. Observe with <code>ls</code> the result of each of the following commands: <pre><code>$ mv arbres/hello.c arbres/bonjour.c\n$ mv abeilles arbres vivant/\n$ mv bidule vivant\n$ mv vivant vie\n</code></pre></li> <li> <p>The <code>cp</code> command for copy, allows you to copy files and directories. Observe the result of the following commands: <pre><code>$ cp vie/arbres/bonjour.c salut.c\n$ mkdir copies\n$ cp salut.c vie/abeilles/truc.txt copies\n$ cp vie/bidule tp_shell copies\n$ cp -R vie/bidule tp_shell copies\n$ cp vie copie_vie\n$ cp -R vie copie_vie\n</code></pre> Describe the operation of the <code>cp</code> command, depending on whether its last argument is an existing directory or not and whether the <code>-R</code> option is present or not.        </p> </li> <li> <p>Finally, the <code>rm</code> command (for remove) allows you to delete files and directories. Observe the result of the following commands: <pre><code>$ rm vie/bidule\n$ rm copies\n$ rm -r copies\n$ rm -R copie_vie\n$ rm -i vie/arbres/bonjour.c vie/abeilles/truc.txt\n</code></pre></p> </li> <li>Delete all files and directories created during this exercise.</li> </ol>"},{"location":"contents/tp1/#exercise-4-manipulating-directories-and-files-2","title":"Exercise 4 : Manipulating directories and files (2)","text":"<p>Create the following tree structure. The <code>~</code> represents the user's home directory. Only <code>rapport.txt</code> and <code>index.html</code> are normal files, the others are all directories. The directories Mail, Rapport and Web directories will be created in a single command using <code>mkdir</code>.</p> <pre><code>stateDiagram-v2\n    ~ --&gt; Mail\n    ~ --&gt; Rapport\n    ~ --&gt; Web\n    Rapport --&gt; rapport.txt\n    Rapport --&gt; Docs\n    Docs --&gt; Afaire\n    Docs --&gt; Fait\n    Web --&gt; index.html</code></pre> <p>Use the <code>touch</code> command to create the normal files and a text editor to give them some content.</p> <p>From your home directory, perform the following operations (there are several possible solutions):</p> <ol> <li>Go directly to <code>~/Rapport/Docs/Afaire</code>.</li> <li>From there, go to <code>~/Rapport/Docs/Fait</code> and copy the file <code>rapport.txt</code> there. Recall that the current directory can be designated by <code>.</code> (a dot).</li> <li>Rename this copy <code>rapport_copie.txt</code>.</li> <li>Go back to <code>~/Rapport</code>.</li> <li>Without changing directories, display the content of the file<code>index.html</code> using the <code>cat</code> command.</li> <li>Without changing directories, list the contents of the <code>Web</code> directory.</li> <li>Get back into <code>~</code> and delete the whole tree structure of this exercise.</li> </ol>"},{"location":"contents/tp1/#exercise-5-built-in-and-external-commands","title":"Exercise 5 : Built-in and external commands","text":"<p>Different types of commands</p> <p>There are several types of commands: external commands, internal commands, shell functions and aliases. External commands are compiled programs or scripts installed on the system. Internal commands (also called built-in commands) are commands built into the shell. Shell functions are functions defined by the user. Aliases are shortcuts for commands defined by the user.</p> <p>The <code>type</code> command allows you to know the type of a command. For example, the <code>type</code> command itself is an internal command:</p> <pre><code>$ type type\ntype is a shell builtin\n</code></pre> <ol> <li>For each command name that appears in the previous exercises, say with the <code>type</code> command which category it belongs to (don't forget <code>type</code>).</li> <li>Can you guess which directories contain most of the programs installed on the system ?</li> </ol>"},{"location":"contents/tp1/#exercise-6-getting-help","title":"Exercise 6 : Getting help","text":"<p>Manual pages</p> <p>The <code>man</code> command provides help for external commands. For built-in commands, you can use the <code>help</code> command.</p> <p>The <code>man</code> command displays the manual pages of the command given as argument. The manual pages are divided into sections. The section is indicated between parenthesis on the top left of the page. </p> <ul> <li>The <code>NAME</code> part describes in one line what the command does. The <code>SYNOPSIS</code> part describes the syntaxes accepted by the command. </li> <li>The <code>DESCRIPTION</code> part describes in detail what the command does. It lists the options and arguments accepted by the command.</li> <li>There may be an <code>EXAMPLES</code> part that gives examples of use of the command.</li> </ul> <p>The manual pages are more or less understandable... But you rarely need to understand everything.</p> <ol> <li>Type the command <code>ls</code>. What are the <code>-l</code> and <code>-a</code> options for ? Press the <code>q</code> key to exit the help and test them.</li> <li>Using the manual, say what the <code>-f</code> option of the <code>rm</code> command is used for and how you can delete a file whose name starts with a dash (like for example <code>-f</code>).</li> <li>Using the <code>help</code> command, print out the help pages for <code>echo</code> and <code>type</code> built-in commands.</li> <li>Using the manual on the <code>touch</code> command, what is the usefulness of this command if it is not to create empty files ?</li> <li> <p>Using the manual on <code>man</code> command, can you find in which section built-in commands are documented ? Then in which section libraries are documented (for instance C standard library) ? Can you guess the difference between the following commands ?</p> <pre><code>$ man 1 printf\n$ man 3 printf\n</code></pre> </li> <li> <p>In the manual pages of <code>mv</code>, observe the first two lines of the <code>SYNOPSIS</code> part. Can you guess what do the brackets mean ? the three dots ? If necessary, refer to the manual pages of the command <code>man</code> .</p> </li> </ol>"},{"location":"contents/tp1/#exercise-7-wildcards","title":"Exercise 7 : Wildcards","text":"<p>Wildcards</p> <p>Wildcards are characters that are used to represent one or more other characters. They are used to specify patterns in commands.</p> <p>Wildcards are expanded by the shell before the command is executed. The shell replaces the wildcard with the list of files that match the pattern. This is called pathname expansion.</p> <p>There are several types of wildcards, but we will only use the most common ones: <code>*</code>, <code>?</code> and <code>[ ]</code>.</p> <ul> <li> <p><code>*</code> can represent a possibily empty string of characters, except if it is the first character of the string and the string starts with a dot (<code>.</code>) ;</p> </li> <li> <p><code>[ ]</code> represents a single character that is in the range of characters specified between the brackets. You can use intervals, like in <code>[a-z]</code> which represents a single lowercase letter or in <code>[0-5]</code> which represents a single digit between <code>0</code> and <code>5</code>. You can invert the search by starting the interval with <code>^</code>: for instance <code>[^0-9]</code> represents a single character that is anything but a digit.</p> </li> <li> <p><code>?</code> represents a single character, except if it is the first character of the string and the string starts with a dot (<code>.</code>).</p> </li> <li> <p>You may get further details in <code>man bash</code> at the Pathname Expansion section.</p> </li> </ul> <ol> <li>Create the <code>tp_joker</code> directory in your home directory. Move to this directory. Create the following (empty) files: <code>annee1</code> <code>Annee2</code> <code>annee4</code> <code>annee45</code> <code>annee41</code> <code>annee510</code> <code>annee_saucisse</code> <code>annee_banane</code> <code>bonbon</code></li> <li> <p>Try to predict the result of the following commands, then test them:</p> <pre><code>$ echo *\n$ echo *_*\n$ echo [ab]*\n$ echo [^ab]*\n$ echo c*\n$ echo ??????\n</code></pre> </li> <li> <p>Using the <code>ls</code> command, list all the files that:</p> <ul> <li>ends with <code>5</code></li> <li>starts with <code>annee4</code></li> <li>starts with <code>annee4</code> and has a maximum of 7 letters</li> <li>starts with <code>annee</code> and whose sixth character is not a digit</li> <li>contains the string <code>ana</code></li> <li>starts with <code>a</code> or <code>A</code></li> <li>whose penultimate character is <code>4</code> or <code>1</code></li> </ul> </li> <li>List all the hidden files in your home directory (files whose name starts with a dot).</li> <li>List all the files starting with <code>std</code> and ending with <code>.h</code> in the <code>/usr/include</code> directory and its subdirectories.</li> </ol>"},{"location":"contents/tp2/","title":"Lab 2 - File system and permissions","text":"<p>Instructions</p> <ul> <li>We recall that in all exercises the <code>$</code> at the beginning of the command represents the prompt, it is not to be entered when you write a command line.</li> <li>For each new command, do not hesitate to consult its manual page with the <code>man</code> command, or to use the <code>--help</code> option (if it is available) to know what it does.</li> </ul>"},{"location":"contents/tp2/#file-system","title":"File system","text":"<p>Linux file system</p> <p>Linux file system is a tree or hierarchy of files and directories. The root directory is <code>/</code> and all other directories are subdirectories of it. Directories are separated by <code>/</code> and files are file names.</p> <p>When you open a shell (i.e. open a terminal), it is in a directory. This directory is called your current directory or working directory.</p> <p>A basic Linux system has tens of thousands of system directories and files. Most of these directories and files are hidden and are not visible by default. These hidden files and directories are used by the operating system to store configuration information and other system information.</p> <p>Root subdirectories are typically reserved for system files. The <code>/home</code> and <code>/tmp</code> directories are used to store temporary files and personal files.</p> <p>Unless you are a system administrator, you do not need to worry about most system files and directories. However, it is important to understand how directories and files are organized so that you can navigate the file system and find the files you need.</p> <p>The following table describes the contents of the main Linux file system directories.</p> Directory Description <code>/bin</code> Contains the programs essential to the operation of the system. <code>/boot</code> Contains the files needed to boot the system. <code>/dev</code> Contains the files representing the devices. <code>/etc</code> Contains the system configuration files. <code>/home</code> Contains the personal directories of the users. <code>/lib</code> Contains shared libraries and kernel modules. <code>/media</code> Contains the mount points of removable devices. <code>/mnt</code> Contains the mount points of temporary file systems. <code>/opt</code> Contains additional software. <code>/proc</code> Contains information about processes and the system. <code>/root</code> Administrator's home directory. <code>/run</code> Contains application runtime files. <code>/sbin</code> Contains the programs essential to the operation of the system. <code>/srv</code> Contains the data of the services provided by the system. <code>/sys</code> Contains information about devices. <code>/tmp</code> Contains temporary files. <code>/usr</code> Contains programs, libraries and configuration files. <code>/var</code> Contains variable files such as logs, mails, databases, etc. <code>/lost+found</code> Contains files recovered during a system crash."},{"location":"contents/tp2/#exercise-1-id-and-etcpasswd","title":"Exercise 1 : <code>id</code> and <code>/etc/passwd</code>","text":"<ol> <li>Type the following commands in a terminal and note the results:    <pre><code>$ id\n</code></pre></li> <li>Then type the same command, but this time with the argument <code>root</code>, note the results.    <pre><code>$ id root\n</code></pre></li> <li>Then display the contents of the file <code>/etc/passwd</code> with the <code>cat</code> command.</li> <li>Search for the lines where your username and the username <code>root</code> appear. What are the differences?</li> <li>Can you deduce what the <code>/etc/passwd</code> file is used for?</li> </ol>"},{"location":"contents/tp2/#normal-files-permissions","title":"Normal files permissions","text":"<p>File protection</p> <p>A Linux system allows many users to access files and directories. To protect files and directories, Linux uses a system of permissions. Permissions are access rights to files and directories. Permissions are associated with users and groups. Users are people who have an account on the system.</p> <p>For normal files, permissions are associated with three categories of users: the owner of the file (usually the one who created the file), the owner group of the file and other users.</p> <p>The permission categories for a file are as follows:</p> <ul> <li>read <code>r</code>: allows you to read the contents of the file.</li> <li>write <code>w</code>: allows you to modify the contents of the file.</li> <li>execute <code>x</code>: allows you to execute the file (if it is a program or a script).</li> </ul> <p>The <code>-l</code> option of the <code>ls</code> command displays the meta-data associated with a file, its name, its size, its owner, its group, ... and in particular its permissions, for example:</p> <p><pre><code>$ ls -l fichier\n-rw-r--r-- 1 user group 0 2019-09-09 10:00 fichier\n</code></pre> The string <code>-rw-r--r--</code> represents the permissions associated with the file. The first character designates the type of file, the next three represent the permissions of the owner, the next three represent the permissions of the owner group and the last three represent the permissions of other users. Permissions are represented by the characters <code>r</code>, <code>w</code> and <code>x</code> for read, write and execute permissions respectively. If the permission is not granted, the character <code>-</code> is used instead.</p> <p>Permissions can be represented by numbers (octal representation) or letters (symbolic representation).</p> <p>The following table gives the correspondence between the two representations:</p> Numbers Letters Description 0 <code>---</code> No permission 1 <code>--x</code> Execute 2 <code>-w-</code> Write 3 <code>-wx</code> Write and execute 4 <code>r--</code> Read 5 <code>r-x</code> Read and execute 6 <code>rw-</code> Read and write 7 <code>rwx</code> Read, write and execute <p>In our example, the permissions <code>-rw-r--r--</code> can be represented in the following ways:</p> User Group Other symbolic <code>rw-</code> <code>r--</code> <code>r--</code> binary 110 100 100 octal 6 4 4"},{"location":"contents/tp2/#exercise-2-file-permissions","title":"Exercise 2 : File permissions","text":"<ol> <li>Create an empty directory and an empty file (these two must be at the same level). Use the <code>ls</code> command and the <code>-l</code> and <code>-d</code> options on each of these two new files to determine the permissions you (respectively your group and others) have on these files. How do you recognize a directory?</li> <li>The following lines give the answer of the <code>ls -ld</code> command on a certain directory (for the needs of the Exercise we have reported only the first and the last field of the result of <code>ls -ld</code>).     <pre><code>drwxr-xr-x a\ndr-xr--r-- b\n-rw-r--r-- c.txt\n--w--w-r-- d.c\n-rwxr-xr-x op\n</code></pre>     Among these files, which are the directories?</li> <li>For each of the files above, give the permissions associated with each of the users (owner, owner group and other users) using the symbolic representation and the octal representation.</li> <li>Give the symbolic representation and the octal representation of the permissions associated with the file <code>/etc/passwd</code>, the command <code>ls</code> and your home directory.</li> </ol>"},{"location":"contents/tp2/#exercise-3-modify-permissions-chmod","title":"Exercise 3 : Modify permissions <code>chmod</code>","text":"<ol> <li>Test the following commands in a terminal and try to understand how the <code>chmod</code> command works (with the symbolic representation).     <pre><code>$ touch f; ls -l f\n$ chmod a= f; ls -l f\n$ chmod o+rw f; ls -l f\n$ chmod u=o f; ls -l f\n$ chmod o-wx f; ls -l f\n$ chmod g+u f; ls -l f\n$ chmod a+x,g-w f; ls -l f\n</code></pre></li> <li>Test the command <code>chmod 644 f; ls -l f</code>. What does this command do?</li> <li>With the two modes of use of <code>chmod</code> (octal and symbolic), modify the permissions of the file <code>f</code> as follows:<ul> <li>execution for all, read and write only for the owner.</li> <li>read and execute for all, no one can write.</li> <li>all permissions for all, no writing for others.</li> <li>read and write for the owner, execution for the group and none for others.</li> </ul> </li> </ol>"},{"location":"contents/tp2/#directories-permissions","title":"Directories permissions","text":"<p>What is a directory ?</p> <p>A directory is a table of file names associated with an index number called inode number which allows to know the information (contained in the inode) concerning this file (size, permissions, timestamp, where to find the content of the file, ...).</p> <p>In a directory, permissions are not associated with files but with the directory itself. The permissions associated with a directory are:</p> <ul> <li>read <code>r</code>: allows you to list the contents of the directory.</li> <li>write <code>w</code>: allows you to modify the contents of the directory (create or delete files).</li> <li>execute <code>x</code>: allows you to open the directory (with the <code>cd</code> command for example).</li> </ul>"},{"location":"contents/tp2/#exercise-4-directories-permissions","title":"Exercise 4 : Directories permissions","text":"<ol> <li>Create a directory <code>rep</code> and two normal files <code>a</code> and <code>b</code> inside this directory.</li> <li>Remove all permissions on the directory <code>rep</code> and try the following commands:     <pre><code>$ cd rep\n$ ls rep\n$ cat rep/a\n$ touch rep/c\n$ rm rep/a\n</code></pre></li> <li>Give only the read permission on the directory <code>rep</code> and try all the commands of question 2. Note the differences.</li> <li>Same question but with only the write permission on <code>rep</code>. Note the differences.</li> <li>This time with only the execute permission on <code>rep</code>. Test the following commands:     <pre><code>$ cd rep\n$ ls rep\n$ echo \"toto\" &gt;&gt; rep/a\n$ cat rep/c\n$ ls -l rep/a\n$ touch rep/c\n$ rm rep/a\n</code></pre></li> <li>With the set of permissions <code>-wx</code> on <code>rep</code> for all users, try to:</li> <li>create a file d in <code>rep</code></li> <li>rename the file b</li> <li>remove all permissions associated with the file d</li> <li>delete the file d</li> </ol>"},{"location":"contents/tp2/#default-permissions","title":"Default permissions","text":"<p>What us <code>umask</code> ?</p> <p><code>umask</code> is a built-in command that allows you to define the default permissions of files and directories that you create. The value of the umask is an octal value that is subtracted from the default permissions. For example, if the umask is 022, the default permissions are 755 for directories and 644 for files.</p>"},{"location":"contents/tp2/#exercise-5-umask-optional","title":"Exercise 5 : <code>umask</code> (optional)","text":"<ol> <li>In a terminal, type the command <code>umask</code> and note the result.</li> <li>Create a directory <code>rep</code> and a file <code>f</code> at the same level as <code>rep</code>. Display the permissions associated with <code>rep</code> and <code>f</code> with the command <code>ls -ld rep f</code>. Convert these permissions to octal representation and note them. Finally, delete <code>rep</code> and <code>f</code>.</li> <li>Change the value of the mask with the command     <pre><code>$ umask 240\n</code></pre></li> <li>Change the value of the mask with the command     <pre><code>$ umask 121\n</code></pre>     then redo question 2.</li> <li>Change the value of the mask with the command     <pre><code>$ umask 666\n</code></pre>     then redo question 2.</li> <li>From all the previous questions, can you deduce how the value of the umask affects the permissions associated with the directories and files you create?</li> <li>Give back the umask its initial value.</li> </ol>"},{"location":"contents/tp3/","title":"Lab3 - Working environment","text":"<p>Instructions</p> <ul> <li>We recall that in all exercises the <code>$</code> at the beginning of the command represents the prompt, it is not to be entered when you write a command line.</li> <li>For each new command, do not hesitate to consult its manual page with the <code>man</code> command, or to use the <code>--help</code> option (if it is available) to know what it does.</li> </ul>"},{"location":"contents/tp3/#shell-variables","title":"Shell variables","text":"<p>Definition and usage of shell variables</p> <p>A variable is a name that is associated with a value. In shell, variables are strings. The development of a variable is the replacement of the variable name by its value.</p> <p>For example, the variable <code>PS1</code> is the variable that contains the shell prompt. In the previous labs, when you typed the command <code>PS1='$ '</code>, you assigned the string <code>$&lt;space&gt;</code> to the variable <code>PS1</code>. When the shell displays the prompt, it develops the variable <code>PS1</code> and displays the string <code>$&lt;space&gt;</code>.</p> <p>Shell variables are environment variables. They are accessible to all processes launched by the shell. They can be listed with the <code>env</code> or <code>printenv</code> command. They can also be listed with the <code>set</code> command which also lists the internal variables of the shell (see the <code>set</code> manual page for more details).</p>"},{"location":"contents/tp3/#exercise-1-shell-variables","title":"Exercise 1 : Shell variables","text":"<ol> <li>Type the following commands in a terminal: <pre><code>$ file_name=hello.c\n$ echo file_name\n$ echo $file_name\n$ echo ${file_name}\n$ touch $file_name\n$ echo $file_namepp\n$ echo ${file_name}pp\n$ rm ${file_name}\n</code></pre></li> <li>Recall what the <code>echo</code> command does. In your opinion, what is the purpose of the <code>$</code> character in front of the variable name <code>file_name</code>?</li> <li>What happens if you ask the shell to display the contents of a variable that does not exist?</li> <li>What happens if you put a space between the variable name and the equal sign <code>=</code>? And between the equal sign and the value?</li> <li>Enter the following commands and try to comment on their effect: <pre><code>$ subject=Alice verb=likes do=programming\n$ sentence=\"$subject $verb $do.\"\n$ echo $sentence\n$ subject=Bob verb=eats do=salad\n$ echo $sentence\n$ echo \"$subject $verb $do.\"\n</code></pre></li> </ol>"},{"location":"contents/tp3/#special-characters-and-inhibition","title":"Special characters and inhibition","text":"<p>Special characters</p> <p>Some characters have a special meaning for the shell: they are said to be special. Conversely, a character that has no other meaning than itself is said to be literal. We list below the special characters; most of them will be seen in detail later in the course.</p> <ul> <li><code>; &lt;newline&gt; | &amp;</code> They end the command that precedes them. We used <code>&lt;newline&gt;</code> to represent the new line character that is entered with the Enter key. The special character <code>|</code> is entered with the key combination <code>Alt Gr-6</code> (<code>Option-Shift-l</code> under mac), it is called pipe. The special character <code>&amp;</code> is entered with the key combination <code>Alt Gr-8</code> and is used to launch commands in the background.</li> <li><code>&lt; &gt;</code> called chevrons, they allow redirections.</li> <li><code>( )</code> to group commands and run them in a sub-shell.</li> <li><code>$</code> for variable development, arithmetic development and command substitution.</li> <li><code>`</code> called backtick or backquote is for command substitution (old syntax). It is entered on the keyboard with the key combination <code>Alt Gr-7</code> followed by a space.</li> <li><code>&lt;space&gt; &lt;tab&gt;</code> delimit command names and arguments.</li> <li><code>\\ ' \"</code> the backslash, the single quote and the double quote which precisely allow to inhibit special characters, that is to make them have their literal meaning.</li> </ul> <p>Then, the following characters have a special meaning in certain contexts and must therefore sometimes be inhibited:</p> <ul> <li><code>* ? ]</code> For path name development.</li> <li><code>#</code> To write comments (unless it is in the middle of a word).</li> <li><code>~</code> For tilde development (home directory).</li> <li><code>=</code> For variable assignment.</li> <li><code>%</code> For task control (job control).</li> </ul>"},{"location":"contents/tp3/#exercise-2-backslash-inhibition","title":"Exercise 2 : Backslash inhibition (<code>\\</code>)","text":"<ol> <li>Test the following commands. <pre><code>$ echo a b\n$ echo a\\ \\ \\ b\n$ touch empty\\ file\n$ rm empty file\n$ rm empty\\ file\n$ echo 3$canadians\n$ echo 3\\$canadians\n$ echo ; echo *\n$ echo \\; echo \\*\n$ echo \"hello\"\n$ echo \\\"hello\\\"\n$ echo 'hello'\n$ echo \\'hello\\'\n$ echo \\\n$ echo \\\\\n</code></pre></li> <li>Referring to the previous questions, answer the following questions:<ul> <li>What does the <code>\\</code> character in front of another character than <code>&lt;newline&gt;</code> do (we recall that the character <code>&lt;newline&gt;</code> is the one that results from pressing the Enter key on the keyboard)?</li> <li>What is the purpose of the character string <code>\\&lt;newline&gt;</code>?</li> <li>How can we get a literal <code>\\</code> character? How to display <code>\\\\</code> using the <code>echo</code> command?</li> </ul> </li> </ol>"},{"location":"contents/tp3/#exercise-3-simple-quotes-inhibition","title":"Exercise 3 : Simple quotes inhibition (<code>'</code>)","text":"<p>Remark</p> <p>The <code>-i</code> option of the <code>rm</code> command allows you to request confirmation before deletion.</p> <ol> <li>Test the following commands: <pre><code>$ touch 'this is an horrible name for a file'\n$ rm -i this is an horrible name for a file\n$ rm -i 'this is an horrible name for a file'\n$ touch p; echo is the * character special ? and ?\n$ echo 'is the * character special ? and ?'\n$ echo 'actually, even the end of line&lt;newline&gt;is a normal character between&lt;newline&gt;apostrophes'\n$ echo 'isn't it only simple quote that is special between simple quotes ?'\n</code></pre>     where <code>&lt;newline&gt;</code> is to be typed with the Enter key of your keyboard.</li> <li>At the sight of the previous experiments (and others to be invented if necessary), answer the following questions:<ul> <li>What are the characters that are special between apostrophes?</li> <li>How to get an apostrophe in a string between apostrophes (tricky question)?</li> <li>How, with a combination of strings between apostrophes and a backslash inhibition, to obtain with <code>echo</code> the following display? <pre><code>Can't we inhibit a variable development (like $var); for example between simple quotes ?\n</code></pre></li> </ul> </li> </ol>"},{"location":"contents/tp3/#exercise-4-double-quotes-inhibition","title":"Exercise 4 : Double quotes inhibition (<code>\"</code>)","text":"<ol> <li>Test the following commands and note your observations: <pre><code>$ echo \"? * and [ are used for path name expansion\"\n$ echo \"~ is the expansion of the home directory\"\n$ echo \"Between \\\" , we can also &lt;newline&gt; write on several&lt;newline&gt; lines\"\n$ name=Alice\n$ echo '$name '\n$ echo \"$name writes a shell script\"\n$ echo \"\\$name writes a shell script\"\n$ echo \"the absolute path to your home directory is `pwd`\"\n$ echo \"the absolute path to your home directory is \\`pwd\\`\"\n$ echo \"the absolute path to your home directory is $(pwd)\"\n$ echo \"the absolute path to your home directory is \\$(pwd)\"\n$ echo \"It is known than 2 + 2 is $((2 + 2))\"\n$ echo \"It is known than 2 + 2 is \\$((2 + 2))\"\n$ echo \"\\\\\\\\\\\"\\$\\`\\*\\'\"\n</code></pre></li> <li>Try those commands on a terminal and note their results: <pre><code>$ myvar=\"Alice&lt;newline&gt; and&lt;newline&gt;Bob\"\n$ echo $myvar are doing a lot of things\n$ echo \"$myvar are doing a lot of things\"\n</code></pre></li> <li>From the previous experiments (and others to be invented if necessary), answer the following questions:<ul> <li>What are the characters that are special between double quotes?</li> <li>What is the role of the <code>\\</code> character between double quotes? In what context is it special, literal?</li> <li>What are the developments that never take place between double quotes?</li> <li>In your opinion, why have several inhibition mechanisms been created?</li> </ul> </li> </ol>"},{"location":"contents/tp3/#pathname-expension","title":"Pathname expension","text":"<p>Pathname expension</p> <p>When a path contains wildcards (Ref. last exercise of Lab1), the shell expands it by replacing the special characters <code>*</code>, <code>?</code> and <code>[</code> by the names of the files that match the regular expression that results from the extension of the path. This mechanism is called pathname expansion.</p> <p>For instance, if the current directory contains the files <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> and <code>e</code>, then the path <code>a*</code> is expanded to <code>a</code>, the path <code>?</code> to <code>a b c d e</code> and the path <code>[a-c]</code> to <code>a b c</code>.</p> <p>Pathname expansion is performed by the shell, before the command is executed. If no file matches the regular expression, the shell leaves the path as it is.</p>"},{"location":"contents/tp3/#exercise-5-files-and-images","title":"Exercise 5 : Files and images","text":"<ol> <li>Create a directory <code>dir</code> and create the empty files <code>file-1.txt</code>, <code>file-2.txt</code>, <code>file-3.txt</code>, <code>file-4.txt</code>, <code>file-5.txt</code>, <code>file-6.txt</code>, <code>file-7.txt</code>, <code>file-8.txt</code>, <code>file-9.txt</code>, <code>config-a.txt</code>, <code>file-b.txt</code> in it.</li> <li>Also create in <code>dir</code> the following empty files <code>img-1.png</code>, <code>img-2.png</code>, <code>img-3.png</code>, <code>img-4.png</code>, <code>img-5.png</code>, <code>img-6.png</code>, <code>img-7.png</code>, <code>img-8.png</code>, <code>img-9.png</code>.</li> <li>Then create in <code>dir</code> two subdirectories <code>files</code> and <code>imgs</code>.</li> <li>Using the pathname expansion and the <code>mv</code> command, move the <code>.txt</code> files to the <code>files</code> directory. Do the same for the <code>.png</code> files in the <code>imgs</code> directory.</li> <li>Give the expression that recognizes the files <code>config-a.txt</code> and <code>file-b.txt</code>. Then remove the files corresponding to this expression. (Thanks to the pathname expansion, you can do it in a single command).</li> <li>Delete the directory <code>dir</code> and its contents.</li> </ol>"},{"location":"contents/tp3/#exercise-6-brace-expansion","title":"Exercise 6 : Brace expansion","text":"<ol> <li>Try the following commands and observe their results: <pre><code>$ echo {a,b,c,d}\n$ echo {a..d}\n$ echo {a..d..2}\n$ echo {1,2,3,4,5,6,7,8,9}\n$ echo {1..9}\n$ echo {1..9..2}\n</code></pre></li> <li>What does the <code>echo {a..d}</code> command ? What is the role of the comma <code>,</code> in the brace expansion ?</li> <li>What does the <code>echo {a..d..2}</code> command ? What is the role of the <code>2</code> in the brace expansion ?</li> <li>Test the following commands and observe their results. <pre><code>$ echo {a..d}*\n$ echo {a..d}.*\n$ echo {a..d}.txt\n</code></pre></li> <li>Create a directory <code>dir</code>. Move to it. Using brace expansion, in a single command, create the empty files <code>file-1.txt</code>, <code>file-2.txt</code>, <code>file-3.txt</code>, <code>file-4.txt</code>, <code>file-5.txt</code>, <code>file-6.txt</code>, <code>file-7.txt</code>, <code>file-8.txt</code>, <code>file-9.txt</code>.</li> <li>Move all <code>.txt</code> files to a directory <code>dir/files</code>.</li> <li>Create a directory <code>dir/imgs</code>. Move to it. Using brace expansion, in a single command, create the empty files <code>img001.png</code>, <code>img002.png</code>, <code>img003.png</code>, <code>img004.png</code>, <code>img005.png</code>, <code>img006.png</code>, <code>img007.png</code>, <code>img008.png</code>, <code>img009.png</code>.</li> <li>Delete the directory <code>dir</code> and all its contents.</li> </ol>"},{"location":"contents/tp3/#command-substitution","title":"Command substitution","text":"<p>Command substitution</p> <p>Command substitution is a mechanism that allows the result of a command to be inserted into a string of characters.</p> <p>Command substitution in a string of characters is another facility offered by the shell. It allows you to capture the output of a command and assign it to a variable or use it as an argument to another command. Since many Linux commands generate output, command substitution can be very useful.</p> <p>There are two syntaxes for command substitution: the old syntax with backticks (<code>`</code>) and the modern syntax with parentheses <code>$(...)</code>. The old syntax is deprecated because it does not allow command substitutions to be nested. We will not present it here.</p>"},{"location":"contents/tp3/#exercise-7-simple-command-substitution","title":"Exercise 7 : Simple command substitution","text":"<ol> <li>Try the following commands and observe their results: <pre><code>$ date\n$ echo date\n$ echo $(date)\n$ today=$(date)\n$ echo $today\n$ echo \"Today is $(date)\"\n</code></pre></li> <li>What does the <code>echo $(date)</code> command do? What is the role of the <code>$</code> in front of the opening parenthesis <code>(</code>?</li> <li>Then type the following commands and observe their results: <pre><code>$ prefix=\"Today is\"\n$ echo $prefix $(date)\n$ echo $prefix $today\n$ echo ${prefix} ${today}\n$ sentence=${prefix} ${today}\n$ sentence=\"${prefix} ${today}\"\n$ echo $sentence\n$ echo \"$sentence\"\n</code></pre></li> <li>Can you deduce the role of the English quotes in command substitution?</li> <li>What is the difference between <code>$(...)</code> and <code>${...}</code>?</li> </ol>"},{"location":"contents/tp3/#exercise-8-nested-command-substitution","title":"Exercise 8 : Nested command substitution","text":"<ol> <li>Test the following commands and observe their results: <pre><code>$ echo $(echo $(date))\n$ echo $(echo $(echo $(date)))\n$ echo $(echo $(echo $(echo $(date))))\n$ echo $(echo $(echo $(echo $(echo $(date)))))\n</code></pre></li> <li>Then type the following commands: <pre><code>$ echo\n</code></pre>     Without executing the following command, can you predict its result?     <pre><code>$ echo $(echo $(echo $(echo $(echo))))\n</code></pre></li> </ol>"},{"location":"contents/tp4/","title":"Lab4 - Text filters, redirection and pipes","text":"<p>Instructions</p> <ul> <li>We recall that in all exercises the <code>$</code> at the beginning of the command represents the prompt, it is not to be entered when you write a command line.</li> <li>For each new command, do not hesitate to consult its manual page with the <code>man</code> command, or to use the <code>--help</code> option (if it is available) to know what it does.</li> <li>Do not hesitate to review the previous Lab if needed.</li> </ul>"},{"location":"contents/tp4/#standard-streams-and-redirection","title":"Standard streams and redirection","text":"<p>Standard output redirection</p> <p>A large number of commands that we have seen so far write their result on the terminal. For example <code>ls, echo, cat,...</code>. We say that these commands write on the standard output (which is connected to the terminal).</p> <p>It is possible to redirect the standard output to a file using the <code>&gt;</code> character. For example: <pre><code>$ ls ~ # displays the contents of the home directory on the standard output\n$ ls ~ &gt; list_files.txt # redirects the standard output to the list_files file\n</code></pre></p> <p>Warning</p> <p>The redirection of the standard output will create the <code>list_files.txt</code> file if it does not exist.</p> <p>The redirection overwrites the contents of an existing file. If we want to add the result to the end of the file, we use the <code>&gt;&gt;</code> character (we call this the append mode).</p>"},{"location":"contents/tp4/#exercise-1-standard-output-redirection-stdout","title":"Exercise 1 : Standard output redirection (STDOUT)","text":"<ol> <li>Try the following commands and observe their results:    <pre><code> $ echo \"Am I on the terminal?\"\n $ echo \"Or in the file?\" &gt; file.txt\n $ cat file.txt\n $ echo \"And me?\" &gt; file.txt\n $ cat file.txt\n $ echo \"I don't want to empty the file\" &gt;&gt; file.txt\n $ cat file.txt\n $ echo \"I want to empty the file\" 1&gt; file.txt\n $ cat file.txt\n $ echo \"I add myself at the end of the line\" 1&gt;&gt; file.txt\n</code></pre></li> <li> <p>Recall the use of <code>cat</code> command (man <code>cat</code>) and from the results of the previous commands:</p> <ul> <li>What is the difference between <code>&gt;</code> and <code>&gt;&gt;</code> ?</li> <li>What is the difference between <code>1&gt;</code> and <code>&gt;</code> ?</li> <li>What is the difference between <code>1&gt;&gt;</code> and <code>&gt;&gt;</code> ?</li> </ul> </li> <li> <p>Move into your home directory and type the following command:     <pre><code>$ ls &gt; list_files.txt; cat list_files.txt\n</code></pre></p> <ul> <li>What does this command ?</li> <li>Can you guess why the string <code>list_files.txt</code> appears in the content of <code>list_files.txt</code></li> </ul> </li> </ol>"},{"location":"contents/tp4/#exercise-2-count-headers-1","title":"Exercise 2 : Count headers (1)","text":"<ol> <li>Using the standard output redirection, create a file <code>include_files.txt</code> that lists all the files in the directory <code>/usr/include</code> whose name ends with <code>.h</code>.</li> <li>Count the number of <code>.h</code> files in the <code>/usr/include</code> directory (hint: <code>wc</code>).</li> <li>Finally add the sentence <code>There are &lt;number&gt; .h files in the /usr/include directory</code> at the end of the <code>include_files.txt</code> file.</li> </ol>"},{"location":"contents/tp4/#exercise-3-standard-error-redirection-stderr","title":"Exercise 3 : Standard error redirection (STDERR)","text":"<ol> <li>In a directory <code>dir</code> create a file <code>file-1.txt</code> whose content is <code>Hello world !</code>.</li> <li>Then create a copy of <code>file-1.txt</code> named <code>file-2.txt</code>. Remove all read permissions on <code>file-2.txt</code>.</li> <li>Then type the following command and note the results (we will have errors!):     <pre><code>$ cat file-1.txt file-2.txt file-3.txt\n</code></pre></li> <li>Which command succeeded? and which commands failed and why?</li> <li>Then redirect the standard output of the previous command to a file <code>result.txt</code>. Observe what is displayed on the terminal, and observe the contents of the file <code>result.txt</code>.</li> <li>Then type the following command and note the results:     <pre><code>$ cat file-1.txt file-2.txt file-3.txt 1&gt; result.txt 2&gt; error.txt\n</code></pre></li> <li>Observe the contents of <code>result.txt</code> and <code>error.txt</code>. What do they contain? In your opinion what does <code>1&gt;</code> and <code>2&gt;</code> mean? Draw a conclusion on the difference between standard output and standard error.</li> </ol> <p>Standard input redirection</p> <p>Some commands read information from the terminal. For example <code>tr, read,...</code>. We say that these commands read on the standard input (which is also connected to the terminal).</p> <p>But many commands also read on the terminal if no file name is given to them as an argument. For example <code>cat, grep, sort,...</code>.</p> <p>It is possible to redirect the standard input of a command to a file using the <code>&lt;</code> character. For example: <pre><code>$ cat &lt; file.txt\n</code></pre> This command displays the contents of the <code>file.txt</code> file on the standard output. We say that the <code>file.txt</code> file is connected to the standard input of the <code>cat</code> command.</p> <p>Warning</p> <p>The <code>file.txt</code> file must exist and we must have the <code>read</code> permission otherwise the <code>cat</code> command will fail.</p>"},{"location":"contents/tp4/#exercise-4-the-return-of-the-cat","title":"Exercise 4 : The return of the <code>cat</code>","text":"<ol> <li>Take a look at the manual of the <code>cat</code> command and find out how it works when it is not given a file as an argument.</li> <li>Then test the following command:    <pre><code>$ cat\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # press the Ctrl key and the d key at the same time\n</code></pre>     How many arguments did the <code>cat</code> command receive? What did she display? Why ?</li> <li>Then test the following command:    <pre><code>$ cat &gt; catout.txt\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # press the Ctrl key and the d key at the same time\n</code></pre>     Then display the contents of the <code>catout.txt</code> file. What does it contain ? Why ?</li> <li>Finally type the following command:     <pre><code>$ cat &lt; catout.txt\n$ cat 0&lt; catout.txt\n</code></pre><ul> <li>How many arguments did the <code>cat</code> command receive? What did she display?</li> <li>What is the difference between <code>&lt;</code> and <code>0&lt;</code> ?</li> </ul> </li> </ol>"},{"location":"contents/tp4/#exercise-5-count-headers-2","title":"Exercise 5 : Count headers (2)","text":"<p>We are going to redo the same exercise as exercise 2 but this time using the redirection of the standard input.</p> <ol> <li>Create a <code>include_files.txt</code> file that lists all the files in the <code>/usr/include</code> directory whose name ends with <code>.h</code>.</li> <li>Then type the following command and comment on its result:     <pre><code>$ wc -l &lt; include_files.txt\n</code></pre></li> <li>Then enter the following command and comment on its result:     <pre><code>$ wc -l &lt; include_files.txt &gt;&gt; include_files.txt\n</code></pre>     and observe the last line of the <code>include_files.txt</code> file.</li> <li> <p>Finally, we would like the last line of the <code>include_files.txt</code> file to be the sentence <code>There are &lt;number&gt; .h files in the /usr/include directory</code>. Where <code>&lt;number&gt;</code> is the result of <code>wc -l &lt; include_files.txt</code>.</p> <p>Find a command that allows you to do this using both the standard output and standard input redirection.</p> <p>Hint</p> <ul> <li>To remove the last line, we can redo the command from the first question.</li> <li>Then think of the <code>echo</code> command and the command substitution.</li> </ul> </li> </ol>"},{"location":"contents/tp4/#pipes","title":"Pipes","text":"<p>Pipes</p> <p>A pipe is a mechanism that allows you to connect the standard output of a command to the standard input of another command. We use the <code>|</code> character to create a pipe.</p> <p>That is to say for <pre><code>$ cmd1 | cmd2\n</code></pre> The standard output of <code>cmd1</code> is connected to the standard input of <code>cmd2</code>.</p>"},{"location":"contents/tp4/#exercise-6-count-headers-i-promise-its-the-last-one","title":"Exercise 6 : Count headers (I promise it's the last one)","text":"<ol> <li>Test the following command and comment on its result:     <pre><code>$ ls /usr/include/*.h | wc -l\n</code></pre>     Where is the result of the <code>ls</code> command redirected? Where is the standard input of the <code>wc</code> command redirected? Where is the result of <code>wc</code> displayed?</li> <li>Then display the sentence <code>There are &lt;number&gt; .h files in the /usr/include directory</code> on the terminal using the <code>echo</code> command and command substitution (hint the command to use and that of question 1).</li> <li>Finally, enter the following command and comment on its result:     <pre><code>wc -l $(ls /usr/include/*.h)\n</code></pre></li> <li>In your opinion why is the result of the last command different from that of question 1?</li> </ol>"},{"location":"contents/tp4/#text-filters","title":"Text filters","text":"<p>What is it ?</p> <p>Text filters are commands that read or can read from their standard input and write modified data to their standard output.</p> <p>Here are some of the most common:</p> <ul> <li><code>head</code> : displays the first lines of its input;</li> <li><code>tail</code> : displays the last lines of its input. With the -f option (to follow, continue to display the end of the file when it is updated) it is one of the favorite commands of system administrators;</li> <li><code>grep</code> : one of the best known commands, displays lines matching a string, or more generally a regular expression in its input;</li> <li><code>cut</code> : selects fields or characters in each line of the standard input;</li> <li><code>sort</code> : sorts its standard input according to criteria.</li> <li><code>tr</code> : replaces characters in its standard input.</li> <li><code>uniq</code> : removes consecutive identical lines in its standard input.</li> </ul>"},{"location":"contents/tp4/#exercise-7-frere-jacques","title":"Exercise 7 : Fr\u00e8re Jacques","text":"<ol> <li>Create a <code>fj</code> file containing these lines:     <pre><code>Fr\u00e8re Jaques, \nFr\u00e8re Jacques,                    \nDormez-vous,\nDormez-vous,\nSonnez les matines,\nSonnez les matines !\nDing !\nDing ! \nDong !\n</code></pre>     with the <code>echo</code> command (the <code>&lt;newline&gt;</code> character corresponds to the enter key on your keyboard):     <pre><code>$ echo 'Fr\u00e8re Jaques,&lt;newline&gt; \n&gt; Fr\u00e8re Jacques,&lt;newline&gt;                     \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Sonnez les matines,&lt;newline&gt; \n&gt; Sonnez les matines !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Dong !' &gt; fj\n</code></pre></li> <li> <p>Then test the following commands and observe their results:     <pre><code>$ cat fj\n$ head fj\n$ tail fj\n$ head -n 2 fj\n$ tail -n 3 fj\n$ grep \"Dormez\" fj\n$ grep -v \"Dormez\" fj\n$ grep \"dormez\" fj\n$ grep -i \"dormez\" fj\n$ sort fj\n$ uniq fj\n$ cut -c 1 fj\n$ cut -c 2 fj\n$ cut -c 1-3 fj\n$ cut -d ' ' -f 1 fj\n$ cut -d ' ' -f 1,2 fj\n</code></pre></p> <ul> <li>Where are the results displayed?</li> <li>What are the <code>-n</code> options of <code>head</code> and <code>tail</code> for?</li> <li>What is the <code>-v</code> option of <code>grep</code> for? What is the <code>-i</code> option of <code>grep</code> for?</li> <li>What are the <code>-c</code> and <code>-d</code> options of <code>cut</code> for?</li> </ul> </li> <li> <p>Then test the command     <pre><code>$ tr a-z A-Z fj\n</code></pre>     In your opinion why does the command fail?</p> </li> <li>Then type the following commands and comment on its result:     <pre><code>$ tr a-z A-Z &lt; fj\n$ tr S D &lt; fj\n$ tail -n 3 fj | tr D B &gt;&gt; fj\n$ cat fj\n</code></pre>     What can you conclude about the <code>tr</code> command?</li> </ol>"},{"location":"contents/tp4/#exercise-8-sort-files-by-size","title":"Exercise 8 : Sort files by size","text":"<p>Base name</p> <p>The base name of a file is the name of the file without its extension. For example the base name of the file <code>/usr/include/stdio.h</code> is <code>stdio</code>.</p> <p>In this exercise, we would like to display on the terminal the base name of the 10 smallest files (bytesize-wise) (in size in bytes) among the <code>.h</code> files in the <code>/usr/include</code> directory.</p> <p>Using the <code>wc</code>, <code>sort</code>, <code>cut</code>, <code>head</code> (or possibly <code>tail</code>) commands, and the pipe redirections, write a command that displays the base name of the 10 smallest files (bytesize-wise) among the <code>.h</code> files in the <code>/usr/include</code> directory.</p> <p>Hint</p> <ul> <li>The <code>-c</code> option of <code>wc</code> gives you the number of bytes in a file.</li> <li>The <code>-n</code> option of <code>sort</code> allows you to sort the lines of a file in numerical order.</li> <li>The <code>-d</code> option of <code>tr</code> removes the characters received as the first argument instead of replacing them.</li> </ul> <p>If you have <code>gcc</code>, you should end up with the following files: <pre><code>pool\nwait\nsyslog\nsyscall\nlastlog\ntermio\nstab\nmemory\nre_comp\nalloca\n</code></pre></p>"},{"location":"contents/tp4/#exercise-9-solo-grep","title":"Exercise 9 : Solo <code>grep</code>","text":"<p><code>grep</code> and directories</p> <ul> <li>The <code>-r</code> option of <code>grep</code> allows you to pass a directory as an argument. And asks him to search in all the files in this directory.</li> <li>The <code>-l</code> option of <code>grep</code> allows you to only display the name of the files that contain the searched string.</li> </ul> <p>Using <code>grep</code> and possibly other commands, find a command line that allows you to:</p> <ol> <li>Display the value of <code>RAND_MAX</code> (it is a constant of the C standard library).</li> <li>Display the absolute path of the files that contain the string <code>127.0.0.1</code> in the files of <code>/etc</code>.</li> <li>Display only the name of the files that contain the string <code>127.0.0.1</code> in the files of <code>/etc</code>. (hint: there is a command called <code>rev</code>).</li> <li>Display the path of the home directory of the <code>games</code> user.</li> </ol>"},{"location":"contents/tp5/","title":"Lab 5 - Processes, and other commands","text":"<p>Instructions</p> <ul> <li>We recall that in all exercises the <code>$</code> at the beginning of the command represents the prompt, it is not to be entered when you write a command line.</li> <li>For each new command, do not hesitate to consult its manual page with the <code>man</code> command, or to use the <code>--help</code> option (if it is available) to know what it does.</li> <li>Do not hesitate to review the previous Lab if needed.</li> <li>Exercises 1, 2, 3 and 4 are mandatory. The rest is optional, but to be finished if you have time.</li> </ul> <p>Last lab session</p> <p>Since it is the last session of the module, take the time to answer the course evaluation questionnaire :) Do not hesitate to tell us what you found good and not that good. Your answers are anonymous and will allow us to improve the course for the next years. Thank you in advance !</p>"},{"location":"contents/tp5/#processes-and-tasks-or-jobs","title":"Processes and tasks (or jobs)","text":"<p>Processes and tasks (or jobs)</p> <p>A processs is a unit of work on an operating system. It can be a program, a script, or a service. Each program you run represents one or more processes. Each process is identified by a unique number called PID (Process IDentifier).</p> <p>Linux offers us several commands to view the running processes.</p> <ul> <li><code>ps</code> allows to display the running processes. By default, <code>ps</code> only displays the processes launched by the current user. To display all processes, use the <code>-e</code> (or <code>-A</code>) option.</li> <li><code>top</code> allows to display the running processes. It can be used interactively, in particular to sort them by CPU usage. You can exit <code>top</code> with the <code>q</code> key.</li> </ul> <p>A task on the other hand is a unit of work of the shell. A task can be a process, or a group of processes but it must have been launched by the shell. The shell has a task control system: it is the ability to execute several commands at the same time. You can run a command in the background and in the foreground.</p> <p>The <code>jobs</code> command displays the tasks currently running.</p> <p>What is the difference between a process and a task?</p> <p>A task is a processes but a process is not necessarily a task.</p>"},{"location":"contents/tp5/#exercise-1-processes-visualization","title":"Exercise 1 - Processes visualization","text":"<ol> <li> <p>Try out the following commands and observe their results. Use <code>man ps</code> to understand the options used.     <pre><code>$ ps\n$ ps -f\n$ ps -u\n$ ps -T\n$ ps -e\n$ ps -U root\n</code></pre></p> </li> <li> <p>The <code>ps</code> command returns the list of running processes. This list contains four columns by default.</p> <p>Information from the <code>ps</code> command</p> <ul> <li>The first column corresponds to the PID (Process IDentifier) of the process.</li> <li>The second column corresponds to the TTY (TeleTYpewriter) on which the process is launched. This is the type of terminal used to launch the process. Here <code>pts/0</code> (pseudo-terminal slave) means that the process was launched in a pseudo-terminal. The number indicated corresponds to the number of the terminal (for example if you have several instances of the terminal open).</li> <li>The third column corresponds to the TIME (time) of execution of the process.</li> <li>The fourth column corresponds to the CMD (CoMmanD) that launched the process.</li> </ul> </li> <li> <p>The standard output of the <code>ps</code> command can be redirected. Using the <code>grep</code> and/or <code>wc</code> command:</p> <ul> <li>Display the number of processes launched by the current user.</li> <li>Display the number of processes launched by the <code>root</code> user.</li> <li>Display the number of processes launched by the current user and whose command is <code>bash</code>.</li> </ul> </li> <li> <p>(Optional) The <code>top</code> command displays the running processes. Once launched, it runs continuously and displays the processes in real time. The <code>h</code> key displays the help and allows you to view the available features, the <code>q</code> key allows you to exit <code>top</code>. Test the <code>top</code> command, display the help then:</p> <ul> <li>Filter the running processes to display only those launched by the current user.</li> <li>Filter the running processes to display only those launched by the <code>root</code> user.</li> <li>Filter the running processes to display only those whose command is <code>bash</code>.</li> </ul> </li> </ol>"},{"location":"contents/tp5/#exercise-2-processes-and-tasks","title":"Exercise 2 - Processes and tasks","text":"<ol> <li>In this exercise we will simulate the execution of a long process. For this, we will use the <code>sleep</code> command which allows to pause the execution of a script for a certain time. Type the command <code>sleep 10</code> and observe what happens.</li> <li> <p>Then test the following commands and comment on the results:     <pre><code>$ ps\n$ sleep 240\n$ C-z # Control + z\n$ ps\n$ fg %1 # fg %&lt;task number&gt;\n$ C-c # Control + c\n$ ps\n</code></pre></p> <ul> <li>In your opinion what does the keyboard shortcut <code>C-z</code> do? and the keyboard shortcut <code>C-c</code>?</li> <li>Redo the commands by typing commands (or anything else in the terminal) between the <code>sleep 240</code> and the <code>C-z</code>. What do you notice?</li> <li>Without going through <code>help fg</code>, can you guess what the command <code>fg %1</code> does? and the command <code>fg</code> in general?</li> <li>Redo the commands by noting each time the PID of the <code>sleep 240</code> process in the outputs of <code>ps</code>. What do you notice?</li> </ul> </li> <li> <p>Create a file <code>gros_processus</code> whose content is the following:     <pre><code>#!/bin/bash\nsleep 120\necho 'Done'\n</code></pre></p> </li> <li>Modify the permissions of the file <code>gros_processus</code> in order to have <code>x</code> permission. Then run the following commands and carefully observe the results:     <pre><code>$ ./gros_processus 1\n$ C-z\n$ ./gros_processus 2 &amp;\n$ jobs\n$ jobs -p\n$ ps\n$ fg %1\n$ C-z\n$ bg %1\n$ jobs\n$ fg %2\n$ C-z\n$ bg %2 # then wait for the processes to finish\n$ jobs\n</code></pre><ul> <li>Which processes allow to place a process in the background? and in the foreground?</li> <li>What difference do you notice between <code>./gro_processus 1</code> then <code>C-z</code> and directly <code>./gros_processus 2 &amp;</code>? (Apart from 1 and 2 of course)?</li> <li>What is the purpose of the <code>-p</code> option of the <code>jobs</code> command?</li> <li>Without going through <code>help bg</code>, can you guess what the commands <code>bg %1</code> and <code>bg %2</code> do? and the <code>bg</code> command in general?</li> <li>What are the different states of the tasks you have observed?</li> </ul> </li> </ol>"},{"location":"contents/tp5/#message-in-the-bottle","title":"Message in the bottle","text":"<p>Communicate with processes</p> <p>When processes have been launched, we have noticed that they can be stopped, restarted and killed. For this, we used the <code>C-z</code>, <code>C-c</code>, <code>fg</code> and <code>bg</code> commands. These commands allow to communicate with the running processes. Actually, the latter send what we call signals to the processes. A signal is a message sent to a process asking it to do something.</p> <p>The command that allows to send signals to a process is <code>kill</code>. This command requires the PID of the process to whom to send the signal (or its task number if it is one). Thus <code>C-z</code>, <code>C-c</code>, <code>fg</code> and <code>bg</code> therefore call the <code>kill</code> command to send signals to the processes.</p> <p>There are several signals, the most common are:</p> <ul> <li><code>SIGINT</code> : signal sent by the <code>C-c</code> key combination. It asks the process to stop.</li> <li><code>SIGTSTP</code> : signal sent by the <code>C-z</code> key combination. It asks the process to pause.</li> <li><code>SIGCONT</code> : signal sent by the <code>bg</code> and <code>fg</code> commands. It asks the process to resume its execution.</li> <li><code>SIGTERM</code> : signal sent by the <code>kill</code> command by default. It asks the process to stop.</li> <li><code>SIGKILL</code> : It asks the process to stop immediately and causes it to crash, understand by that that the process does not have time to finish properly. It is therefore not recommended to use this signal.</li> </ul> <p>The exhaustive list of signals is available with the <code>kill -L</code> command.</p> <p>Who is allowed to send signals to a process?</p> <p>To be able to affect a process, you must of course be its owner or be root.</p>"},{"location":"contents/tp5/#exercise-3-kill-command-order-66","title":"Exercise 3 - <code>kill</code> command (order 66)","text":"<ol> <li>Type the command <code>kill -L</code> and note the numbers associated with the signals <code>SIGINT</code>, <code>SIGTSTP</code>, <code>SIGCONT</code>, <code>SIGTERM</code> and <code>SIGKILL</code>.</li> <li>Then take the <code>gros_processus</code> script from the previous exercise and test the following commands. And comment on the results. <pre><code>$ ./gros_processus 1 &amp; # this will be our process 1\n$ ./gros_processus 2 &amp; # this will be our process 2\n$ ./gros_processus 3 &amp; # this will be our process 3\n$ jobs -p # note the PID of the processes, but they must have been displayed on the screen when they were launched\n$ kill -SIGTSTP &lt;PID of process 1&gt;\n$ jobs\n$ kill -SIGINT %2\n$ jobs\n$ jobs # yes a second time\n$ kill -SIGCONT %1\n$ jobs\n$ kill -s SIGTERM &lt;PID process 1&gt;\n$ jobs\n$ kill -9 &lt;PID of process 3&gt;\n$ jobs\n$ jobs # to see the task [3] disappear\n</code></pre></li> <li>In your opinion what is the difference between <code>SIGINT</code> and <code>SIGTSTP</code>? and between <code>SIGTSTP</code> and <code>SIGTERM</code>?</li> <li>According to your observations on the results of question 2, in how many different ways can the <code>kill</code> command be used to achieve the same result?</li> </ol>"},{"location":"contents/tp5/#other-useful-commands","title":"Other (useful) commands","text":""},{"location":"contents/tp5/#exercise-4-file-compression-and-archiving","title":"Exercise 4 - File compression and archiving","text":"<p>Compress and archive files</p> <p>Archiving a set of files consists in grouping them into a single file. This makes it easier to store or transfer them. While compressing a file consists in reducing its size by removing redundant information. This saves storage space and possibly reduces transfer time.</p> <p>These two processes often go hand in hand. Indeed, we often compress a file before archiving it. There are several tools for compressing and archiving files.</p> <ul> <li><code>gzip</code> (GNU zip): allows to compress a file and whose files have the extension <code>.gz</code>.</li> <li><code>bzip2</code> (block-sorting zip): allows to compress a file and whose files have the extension <code>.bz2</code>.</li> <li><code>zip</code>: allows to compress and archive a set of files and whose files have the extension <code>.zip</code> (standard format of Windows archives)</li> <li><code>tar</code> (tape archive): allows to archive a set of files and whose files have the extension <code>.tar</code>.</li> </ul> <p>We then decompress a file according to its compression and archiving format. </p> <ul> <li><code>gunzip</code> : allows to decompress a file compressed with <code>gzip</code>.</li> <li><code>bunzip2</code> : allows to decompress a file compressed with <code>bzip2</code>.</li> <li><code>unzip</code> : allows to decompress and extract an archive file with <code>zip</code>.</li> </ul> <p>Remark</p> <p><code>tar</code> allows both compression and archiving</p> <ul> <li>The <code>-c</code> option of <code>tar</code> allows to create an archive.</li> <li>The <code>-x</code> option of <code>tar</code> allows to extract an archive.</li> <li>The <code>-f</code> option of <code>tar</code> allows to specify the name of the archive.</li> </ul> <ol> <li>In a directory <code>dir</code> create the following files and directories: <pre><code>dir\n\u251c\u2500\u2500 files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-a.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-b.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-c.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-d.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 file-e.md\n\u2514\u2500\u2500 imgs\n    \u251c\u2500\u2500 img001.png\n    \u251c\u2500\u2500 img002.png\n    \u251c\u2500\u2500 img003.png\n    \u251c\u2500\u2500 img004.png\n    \u2514\u2500\u2500 img005.png\n</code></pre></li> <li>Move into the <code>dir</code> directory. Then type the following command to create an archive <code>files.tar</code> containing the files in the <code>files</code> directory: <pre><code>$ tar -cvf files.tar files\n</code></pre>     Then list the files in <code>dir</code>.</li> <li>Still in <code>dir</code>. Type the following command to create an archive <code>imgs.tar</code> containing the images in the <code>imgs</code> directory: <pre><code>$ tar -cf imgs.tar imgs\n</code></pre>     Then list the files in <code>dir</code>.</li> <li>What can you say about the <code>-v</code> option of <code>tar</code>?</li> <li>Then move into the parent directory of <code>dir</code> and type the following commands: <pre><code>$ tar -czvf dir.tar.gz dir\n$ ls\n$ gunzip dir.tar.gz\n$ ls\n$ tar -xvf dir.tar\n</code></pre><ul> <li>After the <code>gunzip</code> command, what happened to the <code>dir.tar.gz</code> file?</li> <li>What do you think the <code>-z</code> option of tar is for?</li> </ul> </li> </ol>"},{"location":"contents/tp5/#exercise-5-a-very-little-glance-at-vim","title":"Exercise 5 - A very little glance at <code>vim</code>","text":"<p>A terminal based text editor</p> <p><code>vim</code> is a terminal based text editor. It allows you to create, edit and view text files. It is very powerful and widely used by developers. It is very complete and has many features. It is therefore quite difficult to master. We will see some basic commands to be able to use it.</p> <p>In <code>vim</code> there are several modes (it is indicated at the bottom left of the window):</p> <ul> <li>The normal mode: this is the default mode. It allows you to navigate through the file, copy, paste, delete, etc.</li> <li>The insertion mode: it allows to insert text in the file.</li> <li>The command mode: it allows to enter commands to perform actions on the file.</li> <li>The visual mode: it allows to select text in the file.</li> </ul> <p>In general, to return to the normal mode you have to press the <code>ESC</code> key.</p> <ul> <li>To switch from normal mode to insertion mode, press the <code>i</code> key.</li> <li>To switch from normal mode to command mode, press the <code>:</code> key.</li> </ul> <p>In command mode, we will see together some basic commands:</p> <ul> <li><code>:q</code> : quit <code>vim</code>.</li> <li><code>:w</code> : save the file.</li> <li><code>:wq</code> : save the file and quit <code>vim</code>.</li> <li><code>:q!</code> : quit <code>vim</code> without saving the file.</li> </ul> <p>If you want to learn more, you can take a look here and here.</p> <ol> <li>Type the command <code>vim hellovim</code> to create a <code>hellovim</code> file with <code>vim</code>.</li> <li>Once in the editor, switch to insertion mode by typing the <code>i</code> key. Then write the following text:     <pre><code>Hello vim !\n</code></pre></li> <li>Return to normal mode by pressing the <code>ESC</code> key. Then save the file by typing <code>:w</code> and exit <code>vim</code> by typing <code>:q</code>.</li> <li>Then display the contents of <code>hellovim</code> with the <code>cat</code> command.</li> </ol>"},{"location":"contents/tp5/#exercise-6-compile-and-run-c-programs","title":"Exercise 6 - Compile and run C programs","text":"<p><code>gcc</code> compiler</p> <p><code>gcc</code>  is the Linux C compiler. It allows to compile C code. It is widely used by developers. It is very complete and has many features. We will see a preview of its use.</p> <p>The compilation of a C program goes through several steps, which are essentially the following:</p> <ul> <li>Precompilation: it allows to transform the source code into an intermediate code.</li> <li>Compilation: it allows to transform the intermediate code into machine code.</li> <li>Link editing: it allows to link the machine code with the libraries used.</li> <li>Creating the executable: it allows to create the executable.</li> </ul> <ol> <li>Create a <code>hello.c</code> file with the following content:     <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello world !\\n\");\n    return 0;\n}\n</code></pre></li> <li> <p>Move into the directory containing your <code>hello.c</code> file and type the command <code>gcc hello.c</code>. This command will compile your program and create an <code>a.out</code> file which is the executable of your program. Finally, type the command <code>./a.out</code> to run your program.</p> <p>Attention</p> <ul> <li>If you already have an <code>a.out</code> file in your directory, it will be overwritten by the <code>gcc hello.c</code> command.</li> <li><code>a.out</code> is the default name of the executable created by <code>gcc</code>. You can change this name by using the <code>-o</code> option of <code>gcc</code>. For example, <code>gcc hello.c -o hello</code> will create an executable <code>hello</code> instead of <code>a.out</code>.</li> </ul> </li> <li> <p>Then download this archive hello.tar.gz.</p> </li> <li>Extract the files from this archive and move into the <code>hello</code> directory.</li> <li>Type the command  <pre><code>$ gcc main.c hello.c -o run\n</code></pre>     to compile your program. This command will compile your program and create a <code>run</code> file which is the executable of your program. Finally, run your program with the <code>./run</code> command.</li> <li>Delete the <code>run</code> file and then modify the <code>hello.c</code> file so that you have a deliberate error: delete the closing brace of the <code>void hello()</code> function. Then run the commands from question 5 again. What do you notice?</li> <li>Then modify the <code>hello.c</code> file again by putting back the closing brace but add a <code>return 1</code> in the definition of the function (before the closing brace). Then run the commands from question 5 again. What do you notice?</li> <li>Conclude on how <code>gcc</code> manages errors and warnings.</li> </ol>"},{"location":"contents/tp5/#exercise-7-trap-command","title":"Exercise 7 - <code>trap</code> command","text":"<p>Intercept signals</p> <p>The <code>trap</code> command allows to intercept the signals sent to a process. It therefore makes it possible to define actions to be carried out when a signal is sent to a process. Its syntax is as follows: <pre><code>trap 'command1;command2;...' signal1 signal2 ...\n</code></pre> Here <code>command1;command2;...</code> is the list of actions to be performed upon receipt of the signal or signals in the list <code>signal1 signal2 ...</code>.</p> <p>Upon receipt of a <code>SIGINT</code>, for example, we would like to terminate our process cleanly. In this case, we can free all resources before terminating our process. (It's called a graceful shutdown).</p> <ol> <li>Create a <code>graceful_shutdown</code> file with the following content: <pre><code>#!/bin/bash\n\nfunction cmd1()\n{\n    echo\n    echo \"Ok, I am stopping...\" \n} \n\nfunction cmd2()\n{\n    echo\n    echo \"...but with grace\" \n}\n\ntrap 'cmd1;cmd2;exit' SIGINT SIGTERM\n\nwhile true\ndo\n    echo \"Nobody can stop me !\"\n    sleep 10\ndone\n</code></pre></li> <li>Make the <code>graceful_shutdown</code> file executable and then run it.</li> <li>Then type the following commands and comment on the results: <pre><code>$ ./graceful_shutdown\n$ C-c\n</code></pre></li> <li>In your opinion, what does the <code>exit</code> command do?</li> <li>Restart the <code>graceful_shutdown</code> script but this time in the background. Then type the following commands and comment on the results: <pre><code>$ ./graceful_shutdown &amp;\n$ C-c\n</code></pre><ul> <li>What do you notice? As soon as you have the hand on the terminal send a <code>SIGTERM</code> to the <code>graceful_shutdown</code> process.</li> <li>What conclusion can you draw about <code>C-c</code> and background processes?</li> </ul> </li> </ol>"}]}